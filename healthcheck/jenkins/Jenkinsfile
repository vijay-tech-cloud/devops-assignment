pipeline {
  agent any
  options { timestamps(); ansiColor('xterm') }
  environment {
    AWS_REGION   = 'us-east-1'
    AWS_ACCESS_KEY_ID     = credentials('aws-access-key-id')
    AWS_SECRET_ACCESS_KEY = credentials('aws-secret-access-key')
    ECR_REPO    = 'trade-minimal'
    CLUSTER     = 'trade-eks'
    STAGING_NS  = 'staging'
    PROD_NS     = 'prod'
  }
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build & Unit Test') {
      steps {
        sh '''
          cd healthcheck/app
          npm ci
          npm test || true
        '''
      }
    }
  stage('SAST & Secrets') {
    steps {
      sh '''
        set -e
        mkdir -p reports

        # Gitleaks -> write into mounted /out (maps to $PWD/reports)
        docker run --rm \
          -v "$PWD":/repo \
          -v "$PWD/reports":/out \
          zricethezav/gitleaks:latest detect \
            --source=/repo \
            --report-format sarif \
            --report-path /out/gitleaks.sarif || true

        # Trivy FS -> same, write to /out (safe absolute path)
        docker run --rm \
          -v "$PWD":/repo \
          -v "$PWD/reports":/out \
          aquasec/trivy:latest fs /repo \
            --exit-code 0 --severity HIGH,CRITICAL \
            --format sarif --output /out/trivy-fs.sarif || true

        echo "Reports present:" && ls -l reports || true
      '''
    }
    post {
      always {
        archiveArtifacts artifacts: 'reports/*.sarif', allowEmptyArchive: true
      }
    }
}

    stage('Docker Build & SBOM (push to ECR)') {
      steps {
        sh '''
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws ecr describe-repositories --repository-names ${ECR_REPO} || aws ecr create-repository --repository-name ${ECR_REPO}
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com
          IMAGE=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GIT_COMMIT}
          docker build -t $IMAGE ./healthcheck/app
          docker push $IMAGE
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock anchore/syft:latest $IMAGE -o spdx-json > reports/sbom.spdx.json
        '''
      }
      post { always { archiveArtifacts 'reports/sbom.spdx.json' } }
    }
    stage('Terraform Plan/Apply (staging)') {
      when { not { branch 'main' } }
      steps {
        sh '''
          cd healthcheck/terraform
          terraform init -upgrade
          terraform workspace select staging || terraform workspace new staging
          terraform plan -out=tf.plan
          terraform apply -auto-approve tf.plan || terraform apply -auto-approve
        '''
      }
    }
    stage('Deploy: Staging') {
      when { not { branch 'main' } }
      steps {
        sh '''
          aws eks update-kubeconfig --name ${CLUSTER} --region ${AWS_REGION}
          export NAMESPACE=${STAGING_NS}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          export IMAGE_URI=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GIT_COMMIT}
          kubectl apply -f ${WORKSPACE}/deployments/namespace.yml
          envsubst < ${WORKSPACE}/deployments/blue-deployment.yml  | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/green-deployment.yml | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/service.yml          | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/hpa.yml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/pdb.yml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/ingress.yml          | kubectl apply -f -
        '''
      }
    }
    stage('Smoke/E2E on Staging') {
      when { not { branch 'main' } }
      steps {
        sh '''
          URL=$(kubectl -n ${STAGING_NS} get ing tiny -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          docker run --rm -v ${WORKSPACE}/step3_full/tests/newman:/etc/newman postman/newman:alpine             run /etc/newman/collection.json --env-var BASE_URL=http://$URL
        '''
      }
    }
    stage('Quick Load Test (k6)') {
      when { not { branch 'main' } }
      steps {
        sh '''
          URL=$(kubectl -n ${STAGING_NS} get ing tiny -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          docker run --rm -e BASE=http://$URL -v ${WORKSPACE}/step3_full/tests/load:/scripts grafana/k6 run /scripts/k6.js
        '''
      }
    }
    stage('Gate to Prod') {
      when { branch 'main' }
      steps { input message: 'Promote to prod? SLOs green & rollback ready', ok: 'Deploy' }
    }
    stage('Blue/Green to Prod') {
      when { branch 'main' }
      steps {
        sh '''
          cd healthcheck/terraform
          terraform workspace select prod || terraform workspace new prod
          terraform plan -out=tf.plan
          terraform apply -auto-approve tf.plan || terraform apply -auto-approve

          aws eks update-kubeconfig --name ${CLUSTER} --region ${AWS_REGION}
          export NAMESPACE=${PROD_NS}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          export IMAGE_URI=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GIT_COMMIT}

          kubectl apply -f ${WORKSPACE}/deployments/namespace.yml
          envsubst < ${WORKSPACE}/deployments/blue-deployment.yml  | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/green-deployment.yml | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/service.yml          | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/hpa.yml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/pdb.yml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/deployments/ingress.yml          | kubectl apply -f -

          # switch to green
          kubectl -n ${PROD_NS} patch svc tiny -p '{"spec":{"selector":{"app":"tiny","track":"green"}}}'
        '''
      }
    }
    stage('Post-Deploy Verification') {
      when { branch 'main' }
      steps {
        sh '''
          URL=$(kubectl -n ${PROD_NS} get ing tiny -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          docker run --rm -v ${WORKSPACE}/step3_full/tests/newman:/etc/newman postman/newman:alpine             run /etc/newman/collection.json --env-var BASE_URL=http://$URL
          docker run --rm -e BASE=http://$URL -v ${WORKSPACE}/step3_full/tests/load:/scripts grafana/k6 run /scripts/k6.js
        '''
      }
    }
  }
  post {
    always {
      junit allowEmptyResults: true, testResults: 'reports/**/*.xml'
      archiveArtifacts allowEmptyArchive: true, artifacts: 'reports/**'
    }
  }
}
