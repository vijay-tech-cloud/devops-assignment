pipeline {
  agent any
  options { timestamps(); ansiColor('xterm') }
  environment {
    AWS_REGION   = credentials('aws-region')
    AWS_ACCESS_KEY_ID     = credentials('aws-access-key-id')
    AWS_SECRET_ACCESS_KEY = credentials('aws-secret-access-key')
    ECR_REPO    = 'trade-minimal'
    CLUSTER     = 'trade-eks'
    STAGING_NS  = 'staging'
    PROD_NS     = 'prod'
  }
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build & Unit Test') {
      steps {
        sh '''
          cd healthcheck/app
          npm ci
          npm test || true
        '''
      }
    }
    stage('SAST & Secrets') {
      steps {
        sh '''
          mkdir -p reports
          docker run --rm -v $PWD:/repo zricethezav/gitleaks:latest detect --source=/repo --report-format sarif --report-path reports/gitleaks.sarif || true
          docker run --rm -v $PWD:/src aquasec/trivy:latest fs --exit-code 0 --severity HIGH,CRITICAL --format sarif --output reports/trivy-fs.sarif . || true
        '''
      }
      post { always { archiveArtifacts 'reports/*.sarif' } }
    }
    stage('Docker Build & SBOM (push to ECR)') {
      steps {
        sh '''
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws ecr describe-repositories --repository-names ${ECR_REPO} || aws ecr create-repository --repository-name ${ECR_REPO}
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com
          IMAGE=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GIT_COMMIT}
          docker build -t $IMAGE ./healthcheck/app
          docker push $IMAGE
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock anchore/syft:latest $IMAGE -o spdx-json > reports/sbom.spdx.json
        '''
      }
      post { always { archiveArtifacts 'reports/sbom.spdx.json' } }
    }
    stage('Terraform Plan/Apply (staging)') {
      when { not { branch 'main' } }
      steps {
        sh '''
          cd healthcheck/terraform
          terraform init -upgrade
          terraform workspace select staging || terraform workspace new staging
          terraform plan -out=tf.plan
          terraform apply -auto-approve tf.plan || terraform apply -auto-approve
        '''
      }
    }
    stage('Deploy: Staging') {
      when { not { branch 'main' } }
      steps {
        sh '''
          aws eks update-kubeconfig --name ${CLUSTER} --region ${AWS_REGION}
          export NAMESPACE=${STAGING_NS}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          export IMAGE_URI=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GIT_COMMIT}
          kubectl apply -f ${WORKSPACE}/step3_full/k8s/00-namespace.yaml
          envsubst < ${WORKSPACE}/step3_full/k8s/10-deployment-blue.yaml  | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/11-deployment-green.yaml | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/20-service.yaml          | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/30-hpa.yaml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/40-pdb.yaml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/50-ingress.yaml          | kubectl apply -f -
        '''
      }
    }
    stage('Smoke/E2E on Staging') {
      when { not { branch 'main' } }
      steps {
        sh '''
          URL=$(kubectl -n ${STAGING_NS} get ing tiny -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          docker run --rm -v ${WORKSPACE}/step3_full/tests/newman:/etc/newman postman/newman:alpine             run /etc/newman/collection.json --env-var BASE_URL=http://$URL
        '''
      }
    }
    stage('Quick Load Test (k6)') {
      when { not { branch 'main' } }
      steps {
        sh '''
          URL=$(kubectl -n ${STAGING_NS} get ing tiny -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          docker run --rm -e BASE=http://$URL -v ${WORKSPACE}/step3_full/tests/load:/scripts grafana/k6 run /scripts/k6.js
        '''
      }
    }
    stage('Gate to Prod') {
      when { branch 'main' }
      steps { input message: 'Promote to prod? SLOs green & rollback ready', ok: 'Deploy' }
    }
    stage('Blue/Green to Prod') {
      when { branch 'main' }
      steps {
        sh '''
          cd healthcheck/terraform
          terraform workspace select prod || terraform workspace new prod
          terraform plan -out=tf.plan
          terraform apply -auto-approve tf.plan || terraform apply -auto-approve

          aws eks update-kubeconfig --name ${CLUSTER} --region ${AWS_REGION}
          export NAMESPACE=${PROD_NS}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          export IMAGE_URI=$ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GIT_COMMIT}

          kubectl apply -f ${WORKSPACE}/step3_full/k8s/00-namespace.yaml
          envsubst < ${WORKSPACE}/step3_full/k8s/10-deployment-blue.yaml  | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/11-deployment-green.yaml | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/20-service.yaml          | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/30-hpa.yaml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/40-pdb.yaml              | kubectl apply -f -
          envsubst < ${WORKSPACE}/step3_full/k8s/50-ingress.yaml          | kubectl apply -f -

          # switch to green
          kubectl -n ${PROD_NS} patch svc tiny -p '{"spec":{"selector":{"app":"tiny","track":"green"}}}'
        '''
      }
    }
    stage('Post-Deploy Verification') {
      when { branch 'main' }
      steps {
        sh '''
          URL=$(kubectl -n ${PROD_NS} get ing tiny -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          docker run --rm -v ${WORKSPACE}/step3_full/tests/newman:/etc/newman postman/newman:alpine             run /etc/newman/collection.json --env-var BASE_URL=http://$URL
          docker run --rm -e BASE=http://$URL -v ${WORKSPACE}/step3_full/tests/load:/scripts grafana/k6 run /scripts/k6.js
        '''
      }
    }
  }
  post {
    always {
      junit allowEmptyResults: true, testResults: 'reports/**/*.xml'
      archiveArtifacts allowEmptyArchive: true, artifacts: 'reports/**'
    }
  }
}
